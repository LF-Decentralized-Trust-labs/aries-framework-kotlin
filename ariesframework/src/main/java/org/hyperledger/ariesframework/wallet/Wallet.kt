package org.hyperledger.ariesframework.wallet

import kotlinx.coroutines.future.await
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.hyperledger.ariesframework.DecryptedMessageContext
import org.hyperledger.ariesframework.EncryptedMessage
import org.hyperledger.ariesframework.agent.Agent
import org.hyperledger.ariesframework.agent.AgentMessage
import org.hyperledger.ariesframework.toJsonString
import org.hyperledger.indy.sdk.anoncreds.Anoncreds
import org.hyperledger.indy.sdk.crypto.Crypto
import org.hyperledger.indy.sdk.did.Did
import org.hyperledger.indy.sdk.wallet.WalletExistsException
import org.slf4j.LoggerFactory
import java.io.File
import org.hyperledger.indy.sdk.wallet.Wallet as IndyWallet

const val PREFERENCE_NAME = "aries-framework-kotlin"

data class DidInfo(
    val did: String,
    val verkey: String,
)

class Wallet(private val agent: Agent) {
    private val walletExistKey = agent.agentConfig.label + " aries_framework_wallet_exist"
    private val secretIdKey = agent.agentConfig.label + " aries_framework_wallet_secret_id_key"
    private val logger = LoggerFactory.getLogger(Wallet::class.java)
    private val walletCredentials = mapOf(
        "key" to agent.agentConfig.walletKey,
        "key_derivation_method" to "RAW",
    ).toJsonString()

    // Handle of indy wallet.
    var indyWallet: IndyWallet? = null
        private set

    // Master secret id to identify the prover in AnonCreds. This will not be nil after the agent initialization.
    var masterSecretId: String? = null
        private set

    // Public did generated by the ``AgentConfig.publicDidSeed``.
    var publicDid: DidInfo? = null
        private set

    suspend fun initialize() {
        logger.info("Initializing wallet for ${agent.agentConfig.label}")
        if (indyWallet != null) {
            logger.warn("Wallet already initialized.")
            close()
        }

        val walletConfig = mapOf("id" to agent.agentConfig.walletId).toJsonString()
        val userDefaults = agent.context.getSharedPreferences(PREFERENCE_NAME, 0)
        if (!userDefaults.getBoolean(walletExistKey, false)) {
            try {
                IndyWallet.createWallet(walletConfig, walletCredentials).await()
                userDefaults.edit().putBoolean(walletExistKey, true).commit()
            } catch (e: WalletExistsException) {
                logger.warn("Wallet already exists.")
                userDefaults.edit().putBoolean(walletExistKey, true).commit()
            } catch (e: Exception) {
                logger.error("Cannot create wallet: ${e.message}")
                throw e
            }
        }

        indyWallet = IndyWallet.openWallet(walletConfig, walletCredentials).await()
        masterSecretId = userDefaults.getString(secretIdKey, null)
        if (masterSecretId == null) {
            masterSecretId = Anoncreds.proverCreateMasterSecret(indyWallet, null).await()
            userDefaults.edit().putString(secretIdKey, masterSecretId).commit()
        }
    }

    suspend fun close() {
        logger.debug("Closing wallet")
        indyWallet?.closeWallet()?.await()

        indyWallet = null
        masterSecretId = null
    }

    suspend fun delete() {
        logger.debug("Deleting wallet")
        val userDefaults = agent.context.getSharedPreferences(PREFERENCE_NAME, 0)
        if (indyWallet != null) {
            close()
        }

        try {
            IndyWallet.deleteWallet("{\"id\": \"${agent.agentConfig.walletId}\"}", walletCredentials).await()
        } catch (e: Exception) {
            logger.warn("Cannot delete wallet. Try to delete wallet file manually.")
            File(agent.context.filesDir.absolutePath, ".indy_client/wallet/${agent.agentConfig.walletId}/sqlite.db").delete()
        }
        userDefaults.edit().remove(walletExistKey).commit()
        userDefaults.edit().remove(secretIdKey).commit()
    }

    suspend fun initPublicDid(seed: String) {
        publicDid = createDid(seed)
    }

    suspend fun createDid(seed: String? = null): DidInfo {
        var config = "{}"
        if (seed != null) {
            config = mapOf("seed" to seed).toJsonString()
        }
        val result = Did.createAndStoreMyDid(indyWallet, config).await()
        return DidInfo(result.did, result.verkey)
    }

    suspend fun pack(
        message: AgentMessage,
        recipientKeys: List<String>,
        senderKey: String?,
    ): EncryptedMessage {
        val receivers = Json.encodeToString(recipientKeys)
        val data = message.toJsonString().toByteArray()
        val packedMessage = Crypto.packMessage(indyWallet!!, receivers, senderKey, data).await()

        return Json.decodeFromString(packedMessage.toString(Charsets.UTF_8))
    }

    suspend fun unpack(encryptedMessage: EncryptedMessage): DecryptedMessageContext {
        try {
            val encrypted = Json.encodeToString(encryptedMessage).toByteArray()
            val decrypted = Crypto.unpackMessage(indyWallet!!, encrypted).await()

            return Json.decodeFromString(decrypted.toString(Charsets.UTF_8))
        } catch (e: Exception) {
            logger.error("Cannot unpack message: ${e.message}")
            throw e
        }
    }

    companion object {
        /**
         * Generate wallet master key using "RAW" key derivation method.
         */
        suspend fun generateKey(): String {
            return IndyWallet.generateWalletKey(null).await()
        }
    }
}
